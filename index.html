<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />

    <title>Percolation Visualization</title>

    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
      }
      canvas {
        border: 1px solid #ccc;
        image-rendering: pixelated;
        margin-bottom: 20px;
      }
      #controls {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      #pSlider {
        width: 500px;
      }
      #gridSize {
        width: 60px;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <h2>Percolation Visualization</h2>
    <canvas id="gridCanvas"></canvas>
    <div id="controls">
      <div>
        p = <span id="pValue">0.50</span><br />

        <input
          type="range"
          id="pSlider"
          min="0"
          max="1"
          step="0.01"
          value="0.5"
        />
      </div>

      <div>
        Grid rows:
        <input type="number" id="gridSize" value="500" />
      </div>
      <button id="regen">재생성</button>
    </div>

    <script>
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d");

      const pSlider = document.getElementById("pSlider");
      const pValue = document.getElementById("pValue");
      const gridInput = document.getElementById("gridSize");
      const regenBtn = document.getElementById("regen");

      let ROW = parseInt(gridInput.value);
      let COL = ROW * 2;
      let hEdges = [],
        vEdges = [],
        colors = [];

      function hsl2rgb(h, s, l) {
        s /= 100;
        l /= 100;
        let c = (1 - Math.abs(2 * l - 1)) * s;
        let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        let m = l - c / 2;
        let r = 0,
          g = 0,
          b = 0;
        if (h < 60) {
          r = c;
          g = x;
          b = 0;
        } else if (h < 120) {
          r = x;
          g = c;
          b = 0;
        } else if (h < 180) {
          r = 0;
          g = c;
          b = x;
        } else if (h < 240) {
          r = 0;
          g = x;
          b = c;
        } else if (h < 300) {
          r = x;
          g = 0;
          b = c;
        } else {
          r = c;
          g = 0;
          b = x;
        }
        return [
          Math.floor((r + m) * 255),
          Math.floor((g + m) * 255),
          Math.floor((b + m) * 255),
        ];
      }

      function find(parent, x) {
        if (parent[x] !== x) parent[x] = find(parent, parent[x]);
        return parent[x];
      }

      function union(parent, rank, a, b) {
        a = find(parent, a);
        b = find(parent, b);
        if (a === b) return;
        if (rank[a] < rank[b]) [a, b] = [b, a];
        parent[b] = a;
        if (rank[a] === rank[b]) rank[a]++;
      }

      function generateGrid() {
        ROW = parseInt(gridInput.value);
        COL = ROW * 2;
        hEdges = [];
        vEdges = [];
        colors = [];
        for (let i = 0; i < ROW; i++) {
          hEdges[i] = [];
          vEdges[i] = [];
          for (let j = 0; j < COL; j++) {
            hEdges[i][j] = j < COL - 1 ? Math.random() : null;
            vEdges[i][j] = i < ROW - 1 ? Math.random() : null;
            colors.push([
              Math.random() * 360,
              50 + Math.random() * 30,
              40 + Math.random() * 20,
            ]);
          }
        }
      }

      function draw(p) {
        const parent = Array.from({ length: ROW * COL }, (_, i) => i);
        let rank = Array(ROW * COL).fill(0);
        function id(i, j) {
          return i * COL + j;
        }
        for (let i = 0; i < ROW; i++) {
          for (let j = 0; j < COL; j++) {
            if (j < COL - 1 && hEdges[i][j] < p)
              union(parent, rank, id(i, j), id(i, j + 1));
            if (i < ROW - 1 && vEdges[i][j] < p)
              union(parent, rank, id(i, j), id(i + 1, j));
          }
        }

        const img = ctx.createImageData(COL, ROW);
        for (let i = 0; i < ROW; i++) {
          for (let j = 0; j < COL; j++) {
            const root = find(parent, id(i, j));
            const [h, s, l] = colors[root];
            const [r, g, b] = hsl2rgb(h, s, l);
            const idx = (i * COL + j) * 4;
            img.data[idx] = r;
            img.data[idx + 1] = g;
            img.data[idx + 2] = b;
            img.data[idx + 3] = 255;
          }
        }

        canvas.width = COL;
        canvas.height = ROW;
        ctx.putImageData(img, 0, 0);

        canvas.style.width = "1000px"; // 화면 가로 1000px
        canvas.style.height = "500px"; // 화면 세로 500px
      }

      pSlider.oninput = function () {
        const p = parseFloat(pSlider.value);
        pValue.textContent = p.toFixed(2);
        draw(p);
      };
      regenBtn.onclick = () => {
        generateGrid();
        draw(parseFloat(pSlider.value));
      };
      gridInput.onchange = () => {
        generateGrid();
        draw(parseFloat(pSlider.value));
      };

      generateGrid();
      draw(parseFloat(pSlider.value));
    </script>
  </body>
</html>
