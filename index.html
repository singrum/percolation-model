<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Percolation Grid Fast</title>
    <style>
      body {
        margin: 0;
        font-family: sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        text-align: center;
      }
      canvas {
        border: 1px solid #ccc;
        image-rendering: pixelated;
        display: block;
        margin: 20px auto;
      }
      #controls {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 10px;
        margin-bottom: 20px;
      }
      #pSlider {
        width: 500px;
        height: 30px;
      }
      #gridSize {
        width: 80px;
        text-align: center;
      }
      button {
        padding: 6px 12px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <h2>Percolation Visualization</h2>
    <canvas id="gridCanvas"></canvas>
    <div id="controls">
      <div>
        p = <span id="pValue">0.70</span><br />
        <input
          type="range"
          id="pSlider"
          min="0"
          max="1"
          step="0.01"
          value="0.7"
        />
      </div>
      <div>
        Grid size:
        <input type="number" id="gridSize" value="500" min="10" max="800" />
      </div>
      <button id="regen">재생성</button>
    </div>

    <script>
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d");
      const pSlider = document.getElementById("pSlider");
      const pValue = document.getElementById("pValue");
      const gridInput = document.getElementById("gridSize");
      const regenBtn = document.getElementById("regen");

      let N = parseInt(gridInput.value);
      let hEdges = [],
        vEdges = [],
        colors = [];

      // HSL -> RGB 변환
      function hsl2rgb(h, s, l) {
        s /= 100;
        l /= 100;
        let c = (1 - Math.abs(2 * l - 1)) * s;
        let x = c * (1 - Math.abs(((h / 60) % 2) - 1));
        let m = l - c / 2;
        let r = 0,
          g = 0,
          b = 0;
        if (h < 60) {
          r = c;
          g = x;
          b = 0;
        } else if (h < 120) {
          r = x;
          g = c;
          b = 0;
        } else if (h < 180) {
          r = 0;
          g = c;
          b = x;
        } else if (h < 240) {
          r = 0;
          g = x;
          b = c;
        } else if (h < 300) {
          r = x;
          g = 0;
          b = c;
        } else {
          r = c;
          g = 0;
          b = c;
        }
        return [
          Math.floor((r + m) * 255),
          Math.floor((g + m) * 255),
          Math.floor((b + m) * 255),
        ];
      }

      // Union-Find
      function find(parent, x) {
        if (parent[x] !== x) parent[x] = find(parent, parent[x]);
        return parent[x];
      }
      function union(parent, rank, a, b) {
        a = find(parent, a);
        b = find(parent, b);
        if (a === b) return;
        if (rank[a] < rank[b]) [a, b] = [b, a];
        parent[b] = a;
        if (rank[a] === rank[b]) rank[a]++;
      }

      // 그리드 생성
      function generateGrid() {
        N = parseInt(gridInput.value);
        hEdges = [];
        vEdges = [];
        colors = [];
        for (let i = 0; i < N; i++) {
          hEdges[i] = [];
          vEdges[i] = [];
          for (let j = 0; j < N; j++) {
            hEdges[i][j] = Math.random();
            vEdges[i][j] = i < N - 1 ? Math.random() : null;
            const hue = Math.random() * 360;
            const sat = 50 + Math.random() * 30;
            const light = 40 + Math.random() * 20;
            colors.push([hue, sat, light]);
          }
        }
      }

      // 그리기
      function draw(p) {
        const parent = Array.from({ length: N * N }, (_, i) => i);
        let rank = Array(N * N).fill(0);
        function id(i, j) {
          return i * N + j;
        }

        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            if (j < N - 1 && hEdges[i][j] < p)
              union(parent, rank, id(i, j), id(i, j + 1));
            if (i < N - 1 && vEdges[i][j] < p)
              union(parent, rank, id(i, j), id(i + 1, j));
          }
        }

        const img = ctx.createImageData(N, N);
        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            const root = find(parent, id(i, j));
            const [h, s, l] = colors[root];
            const [r, g, b] = hsl2rgb(h, s, l);
            const idx = (i * N + j) * 4;
            img.data[idx] = r;
            img.data[idx + 1] = g;
            img.data[idx + 2] = b;
            img.data[idx + 3] = 255;
          }
        }

        canvas.width = N;
        canvas.height = N;
        ctx.putImageData(img, 0, 0);
      }

      // 이벤트
      pSlider.oninput = function () {
        const p = parseFloat(pSlider.value);
        pValue.textContent = p.toFixed(2);
        draw(p);
      };
      regenBtn.onclick = () => {
        generateGrid();
        draw(parseFloat(pSlider.value));
      };
      gridInput.onchange = () => {
        generateGrid();
        draw(parseFloat(pSlider.value));
      };

      // 초기화
      generateGrid();
      draw(parseFloat(pSlider.value));
    </script>
  </body>
</html>
